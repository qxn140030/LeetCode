You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.

Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.

For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].
While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.
Return true if nums is the only shortest supersequence for sequences, or false otherwise.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

Example 1:
Input: nums = [1,2,3], sequences = [[1,2],[1,3]]
Output: false
Explanation: There are two possible supersequences: [1,2,3] and [1,3,2].
The sequence [1,2] is a subsequence of both: [1,2,3] and [1,3,2].
The sequence [1,3] is a subsequence of both: [1,2,3] and [1,3,2].
Since nums is not the only shortest supersequence, we return false.

Example 2:
Input: nums = [1,2,3], sequences = [[1,2]]
Output: false
Explanation: The shortest possible supersequence is [1,2].
The sequence [1,2] is a subsequence of it: [1,2].
Since nums is not the shortest supersequence, we return false.

Example 3:
Input: nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
Output: true
Explanation: The shortest possible supersequence is [1,2,3].
The sequence [1,2] is a subsequence of it: [1,2,3].
The sequence [1,3] is a subsequence of it: [1,2,3].
The sequence [2,3] is a subsequence of it: [1,2,3].
Since nums is the only shortest supersequence, we return true.


public boolean sequenceReconstruction(int[] nums, List<List<Integer>> sequences) {
    int n = nums.length;
    int[] pos = new int[n + 1];
    for (int i = 0; i < n; i++) {
        pos[nums[i]] = i;
    }
    List<Integer>[] graph = new List[n + 1];
    for (int i = 1; i <= n; i++) {
        graph[i] = new ArrayList<>();
    }
    int[] indegree = new int[n + 1];
    boolean[] seen = new boolean[n + 1];
    int seenCount = 0;
    for (List<Integer> seq : sequences) {
        for (int v : seq) {               // check valid values
            if (!seen[v]) {
                seen[v] = true;
                seenCount++;
            }
        }
        for (int i = 0; i + 1 < seq.size(); i++) {    // build edges
            int u = seq.get(i), v = seq.get(i + 1);
            if (pos[u] > pos[v]) {      // invalid order
                return false;       
            }
            graph[u].add(v);
            indegree[v]++;
        }
    }
    if (seenCount < n) {     // not covering all numbers
        return false; 
    }
    Queue<Integer> queue = new ArrayDeque<>();
    for (int i = 1; i <= n; i++) {
        if (indegree[i] == 0) queue.offer(i);
    }
    int idx = 0;
    while (!queue.isEmpty()) {
        if (queue.size() > 1) {     // not unique
            return false; 
        }
        int cur = queue.poll();
        if (nums[idx] != cur) {     // mismatch
            return false;         
        }
        idx++;
        for (int nei : graph[cur]) {
            indegree[nei]--;
            if (indegree[nei] == 0) {
                queue.offer(nei);
            }
        }
    }
    return idx == n;
}
