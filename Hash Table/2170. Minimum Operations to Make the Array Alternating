You are given a 0-indexed array nums consisting of n positive integers.

The array nums is called alternating if:

nums[i - 2] == nums[i], where 2 <= i <= n - 1.
nums[i - 1] != nums[i], where 1 <= i <= n - 1.
In one operation, you can choose an index i and change nums[i] into any positive integer.

Return the minimum number of operations required to make the array alternating.

Example 1:

Input: nums = [3,1,3,2,4,3]
Output: 3
Explanation:
One way to make the array alternating is by converting it to [3,1,3,1,3,1].
The number of operations required in this case is 3.
It can be proven that it is not possible to make the array alternating in less than 3 operations. 
Example 2:

Input: nums = [1,2,2,2,2]
Output: 2
Explanation:
One way to make the array alternating is by converting it to [1,2,1,2,1].
The number of operations required in this case is 2.
Note that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.

public int minimumOperations(int[] nums) {
    Map<Integer, Integer> evenFreq = new HashMap<>(), oddFreq = new HashMap<>();
    int n = nums.length;
    // Step 1: Count frequencies
    for (int i = 0; i < n; i++) {
        int num = nums[i];
        if (i % 2 == 0) {
            evenFreq.put(num, evenFreq.getOrDefault(num, 0) + 1);
        } else {
            oddFreq.put(num, oddFreq.getOrDefault(num, 0) + 1);
        }
    }
    // Step 2: Find top two most frequent values in even positions
    int[] evenTopTwo = getTopTwo(evenFreq);
    int[] oddTopTwo = getTopTwo(oddFreq);
    int evenCount = (n + 1) / 2;
    int oddCount = n / 2;
    // Step 4: Decide best combination
    if (evenTopTwo[0] != oddTopTwo[0]) {
        return (evenCount - evenTopTwo[1]) + (oddCount - oddTopTwo[1]);
    } 
    int ops1 = (evenCount - evenTopTwo[1]) + (oddCount - oddTopTwo[2]);
    int ops2 = (evenCount - evenTopTwo[2]) + (oddCount - oddTopTwo[1]);
    return Math.min(ops1, ops2);
}
int[] getTopTwo(Map<Integer, Integer> freqMap) {
    int max1 = 0, maxFreq1 = 0, max2 = 0, maxFreq2 = 0;
    for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
        int num = entry.getKey(), freq = entry.getValue();
        // First max: Update if this frequency is higher
        if (freq > maxFreq1) {
            max2 = max1;
            maxFreq2 = maxFreq1;
            max1 = num;
            maxFreq1 = freq;
        } else if (freq > maxFreq2) {
            // Second max: Update if this frequency is higher
            max2 = num;
            maxFreq2 = freq;
        }
    }
    return new int[]{max1, maxFreq1, max2, maxFreq2};  // Return the top two elements and their frequencies
}
