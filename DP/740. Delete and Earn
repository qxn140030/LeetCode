You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:

Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.
Return the maximum number of points you can earn by applying the above operation some number of times.

Example 1:
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.

Example 2:
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.

Approach 1: Top-down DP
Time complexity: O(n + k), where k is the maximun number in the array.
Space complexity: O(n + k)

HashMap<Integer, Integer> points = new HashMap<>();
HashMap<Integer, Integer> cache = new HashMap<>();
public int deleteAndEarn(int[] nums) {
    int maxNumber = 0;
    for (int num : nums) {          // Precompute how many points we gain from taking an element
        points.put(num, points.getOrDefault(num, 0) + num);
        maxNumber = Math.max(maxNumber, num);
    }
    return maxPoints(maxNumber);
}
int maxPoints(int num) {
    if (num == 0) {
        return 0;
    }
    if (num == 1) {
        return points.getOrDefault(1, 0);
    }
    if (cache.containsKey(num)) {
        return cache.get(num);
    }
    int gain = points.getOrDefault(num, 0);
    cache.put(num, Math.max(maxPoints(num - 1), maxPoints(num - 2) + gain));
    return cache.get(num);
}

Approach 2: Bottom-up DP
Time complexity: O(n + k)
Space complexity: O(n + k)

public int deleteAndEarn(int[] nums) {
    HashMap<Integer, Integer> points = new HashMap<>();
    int maxNumber = 0;
    for (int num : nums) {
        points.put(num, points.getOrDefault(num, 0) + num);
        maxNumber = Math.max(maxNumber, num);
    }
    int[] maxPoints = new int[maxNumber + 1];
    maxPoints[1] = points.getOrDefault(1, 0);
    for (int num = 2; num < maxPoints.length; num++) {
        int gain = points.getOrDefault(num, 0);
        maxPoints[num] = Math.max(maxPoints[num - 1], maxPoints[num - 2] + gain);
    }
    return maxPoints[maxNumber];
}

Approach 3: Space Optimized Bottom-up DP
Time complexity: O(n + k)
Space complexity: O(n)

public int deleteAndEarn(int[] nums) {
    HashMap<Integer, Integer> points = new HashMap<>();
    int maxNumber = 0;
    for (int num : nums) {
        points.put(num, points.getOrDefault(num, 0) + num);
        maxNumber = Math.max(maxNumber, num);
    }
    int twoBack = 0, oneBack = points.getOrDefault(1, 0);
    for (int num = 2; num <= maxNumber; num++) {
        int tmp = oneBack;
        oneBack = Math.max(oneBack, twoBack + points.getOrDefault(num, 0));
        twoBack = tmp;
    }
    return oneBack;
}
