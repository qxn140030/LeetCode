You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.
Return any valid arrangement of pairs.
Note: The inputs will be generated such that there exists a valid arrangement of pairs.

Example 1:
Input: pairs = [[5,1],[4,5],[11,9],[9,4]]
Output: [[11,9],[9,4],[4,5],[5,1]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3

Example 2:
Input: pairs = [[1,3],[3,2],[2,1]]
Output: [[1,3],[3,2],[2,1]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 3 == 3 = start1
end1 = 2 == 2 = start2
The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.

Example 3:
Input: pairs = [[1,2],[1,3],[2,1]]
Output: [[1,2],[2,1],[1,3]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 2 == 2 = start1
end1 = 1 == 1 = start2

Approach 1: Eulerian Path (Recursive)
An Eulerian Path is a path through a graph that visits every edge exactly once.
Time complexity: O(V + E)
Space complexity: O(V + E)

public int[][] validArrangement(int[][] pairs) {
    Map<Integer, Deque<Integer>> adj = new HashMap<>();
    Map<Integer, Integer> inDegree = new HashMap<>(), outDegree = new HashMap<>();
    for (int[] pair : pairs) {
        int start = pair[0], end = pair[1];
        adj.computeIfAbsent(start, k -> new ArrayDeque<>()).add(end);
        outDegree.put(start, outDegree.getOrDefault(start, 0) + 1);
        inDegree.put(end, inDegree.getOrDefault(end, 0) + 1);
    }
    int startNode = -1;                           // Find the start node (outDegree == inDegree + 1)
    for (int node : outDegree.keySet()) {
        if (outDegree.get(node) == inDegree.getOrDefault(node, 0) + 1) {
            startNode = node;
            break;
        }
    }
    if (startNode == -1) {                   // If no such node exists, start from the first pair's first element
        startNode = pairs[0][0];
    }
    List<Integer> result = new ArrayList<>();
    visit(startNode, adj, result);
    Collections.reverse(result);
    int[][] pairedResult = new int[result.size() - 1][2];
    for (int i = 1; i < result.size(); i++) {
        pairedResult[i - 1] = new int[] {result.get(i - 1), result.get(i)};
    }
    return pairedResult;
}
void visit(int node, Map<Integer, Deque<Integer>> adj, List<Integer> res) {
    Deque<Integer> neighbors = adj.get(node);
    while (neighbors != null && !neighbors.isEmpty()) {
        int nextNode = neighbors.pollFirst();
        visit(nextNode, adj, res);
    }
    res.add(node);
}
