Given the head of a singly linked list and two integers left and right where left <= right,
reverse the node of the list from position left to right, and return the reversed list. 
Example: 
Input: 1 -> 2 -> 3 -> 4 -> 5, left = 2 and right = 4
Output: 1 -> 4 -> 3 -> 2 -> 5
Follow up:
Can you do it in one pass?

Approach 1: Recursion
two pointers at the left-th and right-th node from the beginning. Once we have such pointers in place, we can recursively reverse nodes between them.
we don't have any backward pointers, so we rely on recursion to simulate the backward pointer.
Time complexity: O(n), process all the nodes at most twice.
Space complexity: O(n), in the worst case we have to reverse the entire list. space occupied by the recursion stack.

class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode leftPre = dummy, leftNode = head, rightNode = head;
        int p1 = left;
        int p2 = right;
        while (--p2 > 0) {
            if (--p1 > 0) {
                leftPre = leftPre.next;
                leftNode = leftNode.next;
            }
            rightNode = rightNode.next;
        }
        ListNode rightAfter = rightNode.next;
        ListNode p = reverse(leftNode, right - left);
        ListNode reversedTail = leftPre.next;
        leftPre.next = p;
        reversedTail.next = rightAfter;
        return left == 1 ? p : head;
    }
    private ListNode reverse(ListNode head, int n) {
        if (head == null || head.next == null || n < 1) {
            return head;
        }
        ListNode p = reverse(head.next, n - 1);
        head.next.next = head;
        head.next = null;
        return p;
    }
}

Approach 2: Iterative Link Reversal
Time complexity: O(n)
Space complexity: O(1)

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while (--left > 0) {
            pre = pre.next;
            right--;
        }
        ListNode beforeReverse = pre, cur = pre.next, reverseTail = cur, after = null;
        while (right-- > 0 && cur != null) { 
            after = cur.next;     
            cur.next = pre;
            pre = cur;
            cur = after;
        }
        beforeReverse.next = pre;
        reverseTail.next = cur;
        return dummy.next;
    }
}
