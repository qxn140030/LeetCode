Question: Given the head of a linked list, retrun the list after sorting it in ascending order.
Follow up: Sort a linked list in O(n log n) time using constant space complexity.
Companies: Amazon, Apple, TikTok, Microsoft, Google.

Approach 1: Top Down Merge Sort (recursion)
recursively splits the original list into two halves, the split continues until there is only one. 
sorts each sublist independently, and eventually merge the sorted lists.
Time complexity: O(nlogn). 
The recursion tree expands in form of a complete binary tree. The number of levels: log⁡2(n). 
At each level, we merge n nodes which takes O(n) time. 
Space complexity: O(logn). 
Since the problem is recursive, we need additional space to store the recursive call stack. 
The maximum depth of the recursion tree is log⁡n.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode mid = getMid(head);
        ListNode left = sortList(head);
        ListNode right = sortList(mid);
        return merge(left, right);
    }

    ListNode merge(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode tail = dummyHead;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }
        tail.next = list1 != null ? list1 : list2;
        return dummyHead.next;
    }

    ListNode getMid(ListNode head) {
        ListNode midPrev = head;
        while (head != null && head.next != null) {
            midPrev = (midPrev == null) ? head : midPrev.next;
            head = head.next.next;
        }
        ListNode mid = midPrev.next;
        midPrev.next = null;
        return mid;
    }
}

Approach 2: Bottom Up Merge Sort (iteration)
splitting the problem into the smallest subproblems and iteratively merge them.



Solution 2: Quicksort. 
Time complexity: O(nlogn). 
Space complexity: O(1).

public class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode leftDummy = new ListNode(0);
        ListNode leftTail = leftDummy;
        ListNode midDummy = new ListNode(0);
        ListNode midTail = midDummy;
        ListNode rightDummy = new ListNode(0);
        ListNode rightTail = rightDummy;
        ListNode pivot = head;              // first element as the pivot.
        while (head != null) {
            if (head.val < pivot.val) {
                leftTail.next = head;
                leftTail = leftTail.next;
            } else if (head.val == pivot.val) {
                midTail.next = head;
                midTail = midTail.next;
            } else {
                rightTail.next = head;
                rightTail = rightTail.next;
            }
            head = head.next;
        }
        leftTail.next = null;
        midTail.next = null;
        rightTail.next = null;
        ListNode left = sortList(leftDummy.next);
        ListNode right = sortList(rightDummy.next);
        return concat(left, midDummy.next, right);
    }
    private ListNode concat(ListNode left, ListNode mid, ListNode right) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        tail.next = left;
        tail = getTail(tail);
        tail.next = mid;
        tail = getTail(tail);
        tail.next = right;
        return dummy.next;
    }
    private ListNode getTail(ListNode head) {
        if (head == null) {
            return head;
        }
        while (head.next != null) {
            head = head.next;
        }
        return head;
    }
}
