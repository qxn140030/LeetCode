Question: Given the head of a linked list, retrun the list after sorting it in ascending order.
Follow up: Sort a linked list in O(n log n) time using constant space complexity.
Companies: Amazon, Apple, TikTok, Microsoft, Google.

Approach 1: Top Down Merge Sort (recursion)
recursively splits the original list into two halves, the split continues until there is only one. 
sorts each sublist independently, and eventually merge the sorted lists.
Time complexity: O(nlogn). 
The recursion tree expands in form of a complete binary tree. The number of levels: log⁡2(n). 
At each level, we merge n nodes which takes O(n) time. 
Space complexity: O(logn). 
Since the problem is recursive, we need additional space to store the recursive call stack. 
The maximum depth of the recursion tree is log⁡n.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode mid = getMid(head);
        ListNode left = sortList(head);
        ListNode right = sortList(mid);
        return merge(left, right);
    }

    ListNode merge(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode tail = dummyHead;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }
        tail.next = list1 != null ? list1 : list2;
        return dummyHead.next;
    }

    ListNode getMid(ListNode head) {
        ListNode midPrev = head;
        while (head != null && head.next != null) {
            midPrev = (midPrev == null) ? head : midPrev.next;
            head = head.next.next;
        }
        ListNode mid = midPrev.next;
        midPrev.next = null;
        return mid;
    }
}


Approach 2: Bottom Up Merge Sort (iteration)
splitting the problem into the smallest subproblems and iteratively merge them. After the first iteration, we get the sorted lists of size 2.
have to keep track of the previous merged list using pointer tail and the next sublist to be sorted using pointer nextSubList.
Time complexity: O(nlogn). 
Space complexity: O(1).


class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        // get the length of the linked list
        int len = 0;
        ListNode cur = head;
        while (cur != null) {
            cur = cur.next;
            len++;
        }
        
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        
        for (int size = 1; size < len; size *= 2) {
            cur = dummyHead.next;
            while (start != null) {
                if (start.next == null) {
                    tail.next = start;
                    break;
                }
                ListNode mid = split(start, size);
                merge(start, mid);
                start = nextSubList;
            }
            start = dummyHead.next;
        }
        return dummyHead.next;
    }

    // splits the list into two parts, first size elements and the rest, return the head of the rest.
    ListNode split(ListNode start, int size) {
        while (size > 1 && head != null) {
            head = head.next;
            size--;
        }
        ListNode rest = head != null ? head.next : null;
        if (head != null) {
            head.next = null;
        }
        return rest;
    }

    // Merge two lists, return the head and tail of the merged list.
    pair<ListNode, ListNode> merge(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode tail = dummyHead;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }
        tail.next = (list1 != null) ? list1 : list2;
        // traverse till the end of merged list to get the tail
        while (tail.next != null) {
            tail = tail.next;
        }
        return [dummyHead.next, tail];
    }
}
