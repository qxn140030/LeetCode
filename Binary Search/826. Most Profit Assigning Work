You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:
- difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and
- worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).
Every worker can be assigned at most one job, but one job can be completed multiple times.
For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.
Return the maximum profit we can achieve after assigning the workers to the jobs.

Example 1:
Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
Output: 100
Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.

Example 2:
Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
Output: 0

Approach 1: TreeMap

public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
    TreeMap<Integer, Integer> jobMap = new TreeMap<>();       // difficulty → max profit
    for (int i = 0; i < difficulty.length; i++) {
        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));
    }
    int totalProfit = 0, res = 0, max = 0;
    for(Integer key : jobMap.keySet()) {        // keys are traversed in ascending order.
        max = Math.max(jobMap.get(key), max);
        jobMap.put(key, max);
    }
    for (int w : worker) {
        Integer bestDifficulty = jobMap.floorKey(w);
        if (bestDifficulty != null) {
            totalProfit += jobMap.get(bestDifficulty);
        }
    }
    return totalProfit;
}

Approach 2: Memoization
public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
    // Step 1: Find the highest skill level among all workers
    int maxAbility = 0;
    for (int w : worker) {
        maxAbility = Math.max(maxAbility, w);
    }
    // Step 2: Create an array to store the best profit available for each difficulty level up to maxAbility
    int[] jobs = new int[maxAbility + 1];
    // Step 3: For each job, record the max profit for its difficulty (if within bounds)
    for (int i = 0; i < difficulty.length; i++) {
        if (difficulty[i] <= maxAbility) {
            jobs[difficulty[i]] = Math.max(jobs[difficulty[i]], profit[i]);
        }
    }
    // Step 4: Build prefix max — for every difficulty level i,
    // make sure jobs[i] holds the best profit for any difficulty ≤ i
    for (int i = 1; i <= maxAbility; i++) {
        jobs[i] = Math.max(jobs[i], jobs[i - 1]);
    }
    // Step 5: Sum up profits for each worker based on their ability
    int netProfit = 0;
    for (int ability : worker) {
        netProfit += jobs[ability];    // best profit for this worker's ability
    }
    return netProfit;
}
