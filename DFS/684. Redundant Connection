In this problem, a tree is an undirected graph that is connected and has no cycles.
You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. 
The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.
Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.
Example 1:
            1 -- 2
             \  /
              3
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]

Example 2:
            2 -- 1 -- 5
            |    |
            3 -- 4
Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]

Approach 1: DFS
Time complexity: O(n^2), where n is the number of vertices (and also the number of edges) in the graph. In the worst case, for every edge we include, we have to search every previously-occurring edge of the graph.
Space complexity: O(n), the current construction of the graph has at most n nodes.

class Solution {
    Set<Integer> visit = new HashSet<>();
    public int[] findRedundantConnection(int[][] edges) {
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int[] e : edges) {
            if (adj.containsKey(e[0]) && adj.containsKey(e[1])) {
                visit.clear();                                    // Note.
                if (dfs(adj, e[0], e[1])) {                       // we already have a path connect these two vertices.
                    return new int[]{e[0], e[1]};
                }
            }
            if (!adj.containsKey(e[0])) {
                adj.put(e[0], new ArrayList<>());
            }
            adj.get(e[0]).add(e[1]);
            if (!adj.containsKey(e[1])) {
                adj.put(e[1], new ArrayList<>());
            }
            adj.get(e[1]).add(e[0]);
        }
        return new int[0];
    }
    private boolean dfs(Map<Integer, List<Integer>> adj, int source, int target) {
        if (!visit.contains(source)) {
            if (source == target) {
                return true;
            }
            visit.add(source);
            for (int i : adj.get(source)) {
                if (dfs(adj, i, target)) {
                    return true;
                }
            }
        }
        return false;
    }
}
