Given an array of distinct strings words, return the minimal possible abbreviations for every word.
The following are the rules for a string abbreviation:
The initial abbreviation for each word is: the first character, then the number of characters in between, followed by the last character.
If more than one word shares the same abbreviation, then perform the following operation:
Increase the prefix (characters in the first part) of each of their abbreviations by 1.
For example, say you start with the words ["abcdef","abndef"] both initially abbreviated as "a4f". 
Then, a sequence of operations would be ["a4f","a4f"] -> ["ab3f","ab3f"] -> ["abc2f","abn2f"].
This operation is repeated until every abbreviation is unique.
At the end, if an abbreviation did not make a word shorter, then keep it as the original word.

Example 1:
Input: words = ["like","god","internal","me","internet","interval","intension","face","intrusion"]
Output: ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]

Example 2:
Input: words = ["aa","aaa"]
Output: ["aa","aaa"]

Appraoch 1: Group + Trie
Time complexity: O(C), where C is the number of characters across all words in the given array.
Space complexity: O(C)

class Solution {
    public List<String> wordsAbbreviation(List<String> words) {
        int n = words.size();
        Map<String, List<IndexedWord>> groups = new HashMap();
        for (int i = 0; i < n; i++) {                               // Group words that get the same abbreviation
            String w = words.get(i);
            String ab = abbrev(w, 0); 
            groups.computeIfAbsent(ab, k -> new ArrayList<>()).add(new IndexedWord(w, i));
        }
        String[] ans = new String[n];
        for (Map.Entry<String, List<IndexedWord>> entry : groups.entrySet()) {
            List<IndexedWord> group = entry.getValue();
            if (group.size() == 1) {
                IndexedWord iw = group.get(0);
                ans[iw.index] = entry.getKey();
                continue;
            }
            TrieNode root = new TrieNode();
            for (IndexedWord iw : group) {
                TrieNode cur = root;
                for (char c : iw.word.substring(1).toCharArray()) {
                    int idx = c - 'a';
                    if (cur.children[idx] == null) {
                        cur.children[idx] = new TrieNode();
                    }
                    cur.count++;
                    cur = cur.children[idx];
                }
            }
            for (IndexedWord iw : group) {
                TrieNode cur = root;
                int i = 1;
                for (char c : iw.word.substring(1).toCharArray()) {
                    if (cur.count == 1) {
                        break;
                    }
                    cur = cur.children[c - 'a'];
                    i++;
                }
                ans[iw.index] = abbrev(iw.word, i - 1);
            }
        }
        return Arrays.asList(ans);
    }
    String abbrev(String word, int i) {
        int n = word.length();
        if (n - i <= 3) {
            return word;
        }
        return word.substring(0, i + 1) + (n - i - 2) + word.charAt(n - 1);
    }
}
class TrieNode {
    TrieNode[] children;
    int count;    // to count shared prefixes
    TrieNode() {
        children = new TrieNode[26];
    }
}
class IndexedWord {   // pairs original word with its index
    String word;
    int index;
    IndexedWord(String w, int i) {
        word = w;
        index = i;
    }
}
