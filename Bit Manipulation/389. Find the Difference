Question: You are given two strings s and t.
String t is generated by random shuffling string s and then add one more letter at a random position.
Return the letter that was added to t.

Example 1:
Input: s = "abcd", t = "abcde"
Output: "e"

Example 2:
Input: s = "", t = "y"
Output: "y"

Approach 1: Sorting
Time complexity: O(n)
Space complexity: O(n)

public class Solution {
    public char findTheDifference(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        Arrays.sort(ss);
        Arrays.sort(tt);
        for (int i = 0; i < ss.length; i++) {
            if (ss[i] != tt[i]) {
                return tt[i];
            }
        }
        return tt[tt.length - 1];
    }
}

Approach 1: HashMap
Time complexity: O(n)
Space complexity: O(1), the total number of unique characters and eventually buckets in the hash map are 26.

public class Solution {
    public char findTheDifference(String s, String t) {
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) {
                map.put(c, map.get(c) + 1);
            } else {
                map.put(c, 1);
            }
        }
        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            if (!map.containsKey(c) || map.get(c) == 0) {
                return c;
            } else {
                map.put(c, map.get(c) - 1);
            }
        }
        return ' ';
    }
}

Approach 3: Bit manipulation
Time complexity: O(n)
Space complexity: O(1)

class Solution {
    public char findTheDifference(String s, String t) {
        // Initialize ch with 0, because 0 ^ X = X
        char ch = 0;
        for (int i = 0; i < s.length(); i++) {
            ch ^= s.charAt(i) ^ t.charAt(i);
        }
        // What is left after XORing everything is the difference.
        return ch ^= t.charAt(t.length() - 1);
    }
}
