A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For 1-byte character, the first bit is a 0, followed by its unicode code.
For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.
This is how the UTF-8 encoding would work:

     Number of Bytes   |        UTF-8 octet sequence
                       |              (binary)
   --------------------+---------------------------------------------
            1          | 0xxxxxxx
            2          | 110xxxxx 10xxxxxx
            3          | 1110xxxx 10xxxxxx 10xxxxxx
            4          | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
x denotes a bit in the binary form of a byte that may be either 0 or 1.
Note:
The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each
integer represents only 1 byte of data.
Example 1:
data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.
Return true.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.

Example 2:
data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.
Return false.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.

Constraints:
1 <= data.length <= 2 * 104
0 <= data[i] <= 255

public boolean validUtf8(int[] data) {
  int remaining = 0;                           // number of bytes remaining for current character
  for (int b : data) {
      b &= 0xFF;                               // only keep the lowest 8 bits
      if (remaining == 0) {                    // Count how many leading 1s
          if ((b >> 5) == 0b110) {
              remaining = 1;                   // 2-byte
          } else if ((b >> 4) == 0b1110) {
              remaining = 2;                   // 3-byte
          } else if ((b >> 3) == 0b11110) {
              remaining = 3;                   // 4-byte
          } else if ((b >> 7) != 0) {
              return false;                    // 1-byte must start with 0xxxxxxx
          }
      } else {                                 // Must start with 10xxxxxx
          if ((b >> 6) != 0b10) {
              return false;
          }
          remaining--;
      }
  }
  return remaining == 0;
}

public class Solution {
    public boolean validUtf8(int[] data) {
        int count = 0;
        int mask = 0b10000000;
        for (int i : data) {
            if (count > 0) {
                if ((i & mask) == mask) {
                    count--;
                } else {
                    return false;
                }
            } else {
                count = getHead(i);
                if (count < 0) {
                    return false;
                }
            }
        }
        return count == 0;
    }
    private int getHead(int n) {              // Note: the order of if statement is important.
        if ((n & 0b11110000) == 0b11110000) {
            return 3;
        }
        if ((n & 0b11100000) == 0b11100000) {
            return 2;
        }
        if ((n & 0b11000000) == 0b11000000) {
            return 1;
        }
        if ((n & 0b10000000) == 0b10000000) {
            return -1;
        }
        return 0;
    }
}
