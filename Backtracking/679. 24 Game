You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.

You are restricted with the following rules:

The division operator '/' represents real division, not integer division.
For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.
Every operation done is between two numbers. In particular, we cannot use '-' as a unary operator.
For example, if cards = [1, 1, 1, 1], the expression "-1 - 1 - 1 - 1" is not allowed.
You cannot concatenate numbers together
For example, if cards = [1, 2, 1, 2], the expression "12 + 12" is not valid.
Return true if you can get such expression that evaluates to 24, and false otherwise.

Example 1:
Input: cards = [4,1,8,7]
Output: true
Explanation: (8-4) * (7-1) = 24

Example 2:
Input: cards = [1,2,1,2]
Output: false


double EPS = 1e-6, TARGET = 24.0;
public boolean judgePoint24(int[] cards) {
    List<Double> nums = new ArrayList<>();
    for (int x : cards) {
        nums.add((double) x);
    }
    return dfs(nums);
}
boolean dfs(List<Double> nums) {
    int n = nums.size();
    if (n == 1) {        // Base case: only one number left, check if it's close to 24
        return Math.abs(nums.get(0) - TARGET) < EPS;
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            List<Double> next = new ArrayList<>();
            for (int k = 0; k < n; k++) {
                if (k != i && k != j) {
                    next.add(nums.get(k));
                }
            }
            double a = nums.get(i), b = nums.get(j);
            List<Double> candidates = new ArrayList<>();     // All possible results from a and b
            candidates.add(a + b);
            candidates.add(a - b);
            candidates.add(b - a);
            candidates.add(a * b);
            if (Math.abs(b) > EPS) {
                candidates.add(a / b);
            }
            if (Math.abs(a) > EPS) {
                candidates.add(b / a);
            }
            for (double val : candidates) {      // Try each candidate as the new number, recurse
                next.add(val);
                if (dfs(next)) {
                    return true;
                }
                next.remove(next.size() - 1);    // backtrack
            }
        }
    }
    return false;
}
