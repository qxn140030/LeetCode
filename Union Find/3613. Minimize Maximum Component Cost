You are given an undirected connected graph with n nodes labeled from 0 to n - 1 and a 2D integer array edges where edges[i] = [ui, vi, wi] denotes an undirected edge between node ui and node vi with weight wi, and an integer k.

You are allowed to remove any number of edges from the graph such that the resulting graph has at most k connected components.

The cost of a component is defined as the maximum edge weight in that component. If a component has no edges, its cost is 0.

Return the minimum possible value of the maximum cost among all components after such removals.

Example 1:
Input: n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2
Output: 4
Explanation:
Remove the edge between nodes 3 and 4 (weight 6).
The resulting components have costs of 0 and 4, so the overall maximum cost is 4.

Example 2:
Input: n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1
Output: 5
Explanation:
No edge can be removed, since allowing only one component (k = 1) requires the graph to stay fully connected.
That single componentâ€™s cost equals its largest edge weight, which is 5.

class Solution {
    public int minCost(int n, int[][] edges, int k) {
        if (k >= n) {                                   // If we can have at least n components,
            return 0;                                   // we can isolate every node -> max edge in any component is 0
        }
        Arrays.sort(edges, (e1, e2) -> Integer.compare(e1[2], e2[2]));     // Sort edges by weight ascending
        DSU dsu = new DSU(n);
        int i = 0, m = edges.length;
        while (i < m) {
            int w = edges[i][2];
            while (i < m && edges[i][2] == w) {          // Union all edges having weight == w
                dsu.union(edges[i][0], edges[i][1]);
                i++;
            }
            if (dsu.comps <= k) {
                return w; 
            }
        }
        return 0;        // For connected graphs and k >= 1, we should have returned above
    }
}
class DSU {
    int[] parent, rank;
    int comps;
    public DSU(int n) {
        comps = n;
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    public int find(int x) {
        while (parent[x] != x) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    boolean union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) {
            return false;
        }
        int rx = rank[px], ry = rank[py];
        if (rx == ry) {
            parent[py] = px;
            rank[px]++;
        } else if (rx > ry) {
            parent[py] = px;
        } else {
            parent[px] = py;
        }
        comps--;
        return true;
    }
}
